const express = require("express")

const app = express();



app.use("/about",(req, res) => {
    res.send("about page ")
})

app.use("/login",(req, res) => {
    res.send("login page")
})

app.use("/",(req, res) => {
    res.send("hello hiii ")
})

app.listen(3000,() => {
    console.log("server live on port 3000.............")
})


# advanse thing of routing 

const express = require("express")

const app = express();



 app.get("/ab?c",(req,res) => {
     res.send("testing router")
 })

 app.get("/ab+c",(req,res) => {
     res.send("testing router")
 })

app.get("/ab*c",(req,res) => {
    res.send("testing router")
})

app.listen(3000,() => {
    console.log("server live on port 3000.............")
})






# many router handler 





app.get("/user",(req,res,next) => {
    console.log(req.query);
    res.send("testing router")
    next();
},(req,res) => {
    console.log(req.query);
    res.send("2nd testing router")
})

 app.get("/user/:usreId/:password",(req,res) => {
     console.log(req.params);
     console.log(req.query)
     res.send("testing router")
 })


 # middlewares

const express = require("express")

const {adminAuth,userAuth} = require("./middlewares/auth.js")

const app = express();


app.use("/",userAuth);

app.use("/admin/profile",(req,res) =>{
    res.send("admin is checked");
})

app.use("/user/profile",userAuth,(req,res) =>{
    res.send("user is checked");
})


{ # minddleware 
    const userAuth = (req, res, next) => {
    const token = "xyz";
    const isAuthenticated = token === "xyz";
    if (!isAuthenticated){
        res.status(401).send("unAutheriesed access")
    }else{
        console.log("checked user");
        next();
    }
}
}



app.listen(3000, () => {
    console.log("server live on port 3000.............")
})


# Error handling 


app.use("/getUserDate", (req, res) => {
    // try {
    throw new Error("cbhbhs");
    res.send("this is user date");
    // } catch (error) {
    //     res.status(500).send("something want wrong in this code")        
    // }
})


app.use("/", (err, req, res, next) => {
    if (err) {
        res.status(500).send("something want wrong");
    }
})




# Mongoose query

1. Mongoose models provide several static helper functions for CRUD operations. Each of these functions returns a mongoose Query object.

2. A mongoose query can be executed in one of two ways. First, if you pass in a callback function, Mongoose will execute the query asynchronously and pass the results to the callback.

Model.deleteMany() 
1. ans : deleteMany({}) delete to many data to only one time 
Model.deleteOne()
2. ans : deleteOne() selecte the one user and data set an delete the data 
Model.find()
3. ans : find() query just use to find the user and data by any uniqe valaue and perameter 
Model.findById()
4. ans :
<!-- {  -->
    n simple words, model.findById() is a function in MongoDB's Mongoose library. It is used to find a document in the database by its unique _id field.

Here’s how it works:

You provide the unique _id of the document you want to find.
Mongoose searches the collection (table) for a document with that _id.
If it finds the document, it returns it; otherwise, it returns null.
Example:
javascript
Copy code
const User = require('./models/user'); // Assume this is your Mongoose model

User.findById('647f3f928a76b3f1e43d2b9a', (err, user) => {
  if (err) {
    console.log('Error:', err);
  } else if (user) {
    console.log('Found User:', user);
  } else {
    console.log('No user found with that ID');
  }
});
Key Points:
The _id is automatically generated by MongoDB when you create a document.
It returns a Mongoose document or null if no match is found.
It can also be used with async/await or Promises for better handling of asynchronous code.

<!-- } -->


Model.findByIdAndDelete()

5. ans: 

<!-- model.findByIdAndDelete() is a Mongoose method used to find a document in a MongoDB collection by its _id and delete it. Here's a simple explanation:

What It Does:
You provide the _id of the document you want to delete.
Mongoose searches the collection for a document with that _id.
If it finds the document, it deletes it and returns the deleted document.
If no document is found, it returns null.


Example:
javascript

const User = require('./models/user'); // Assume this is your Mongoose model

User.findByIdAndDelete('647f3f928a76b3f1e43d2b9a', (err, deletedUser) => {
  if (err) {
    console.log('Error:', err);
  } else if (deletedUser) {
    console.log('Deleted User:', deletedUser);
  } else {
    console.log('No user found with that ID');
  }
});
Key Points:
Returns Deleted Document: The method returns the deleted document, which can be useful if you want to see what was removed.
Returns null: If no document is found with the given _id, it returns null.
Asynchronous Operation: You can use it with callbacks, Promises, or async/await.


With async/await:

javascript

try {
  const deletedUser = await User.findByIdAndDelete('647f3f928a76b3f1e43d2b9a');
  if (deletedUser) {
    console.log('Deleted User:', deletedUser);
  } else {
    console.log('No user found with that ID');
  }
} catch (err) {
  console.log('Error:', err);
}
It’s a quick and convenient way to both locate and remove a document by its unique identifier. -->

Model.findByIdAndRemove()

Model.findByIdAndUpdate()

Model.findOne()

Model.findOneAndDelete()

Model.findOneAndReplace()
6. syntex : model.findOneAndReplace(filter, replacement, options, callback);

parameter:

filter: Criteria to find the document (e.g., { name: "John" }).
replacement: The new document to replace the matched one. Must include all fields you want, as it overwrites the old document completely.
options (optional):
{ returnDocument: "before" | "after" } (default: "before") - Whether to return the document before or after replacement.
{ upsert: true | false } (default: false) - Creates a new document if no match is found.
callback (optional): A function to handle the result.




Model.findOneAndUpdate()
7. 

<!-- 

Model.findOneAndUpdate() 

is a Mongoose method used to find a single document in a MongoDB collection that matches a given filter and update it with new data. It is commonly used when you want to modify specific fields of an existing document.

What It Does:
It searches for a document that matches the filter criteria.
Updates the document with the specified update data.
Returns either the document before or after the update, depending on the options.


Syntax:
javascript

Model.findOneAndUpdate(filter, update, options, callback);
Parameters:
filter: The criteria to find the document (e.g., { name: "John" }).
update: The changes to apply to the document (e.g., { $set: { age: 30 } }).
options (optional):
{ returnDocument: "before" | "after" } (default: "before") - Whether to return the document before or after the update.
{ upsert: true | false } (default: false) - Creates a new document if no match is found.
{ new: true } (legacy) - An older version of returnDocument: "after".
callback (optional): A function to handle the result.


Example:
javascript

const User = require('./models/user'); // Assume this is your Mongoose model

User.findOneAndUpdate(
  { name: 'John' },              // Filter
  { $set: { age: 30 } },         // Update
  { returnDocument: 'after' },   // Options
  (err, updatedDoc) => {         // Callback
    if (err) {
      console.log('Error:', err);
    } else if (updatedDoc) {
      console.log('Updated Document:', updatedDoc);
    } else {
      console.log('No document matched the filter.');
    }
  }
);


With async/await:

try {
  const updatedDoc = await User.findOneAndUpdate(
    { name: 'John' },              // Filter
    { $set: { age: 30 } },         // Update
    { returnDocument: 'after' }    // Options
  );
  
  if (updatedDoc) {
    console.log('Updated Document:', updatedDoc);
  } else {
    console.log('No document matched the filter.');
  }
} catch (err) {
  console.error('Error:', err);
}
Key Points:

Partial Updates:  This method modifies only the fields specified in the update object.
Atomic Operation: The find and update happen as a single, atomic operation.
Upsert Support:   If no document matches the filter and upsert is true, it creates a new document using the filter and update data.
Return Options:   By default, it returns the document before the update. Use { returnDocument: 'after' } to get the updated document.
Modifiers:        You can use MongoDB update operators (e.g., $set, $inc, $unset) in the update object for flexible modifications.


Example with Upsert:
javascript

const result = await User.findOneAndUpdate(
  { name: 'Jane' },              // Filter
  { $set: { age: 25 } },         // Update
  { upsert: true, returnDocument: 'after' } // Create document if not found
);
console.log(result);
This is a powerful method for updating or creating a document in one step! -->
Model.replaceOne()

Model.updateMany()

Model.updateOne()




# AUTH MIDDLEWARES AND DOMMI PREACTISE

const adminAuth = (req, res, next) => {
    const token = "xyz";
    const isAuthenticated = token === "xyz";
    if (!isAuthenticated){
        res.status(401).send("unAutheriesed access")
    }else{
        console.log("checked admin");
        next();
    }
}


const userAuth = (req, res, next) => {
    const token = "xyz";
    const isAuthenticated = token === "xyz";
    if (!isAuthenticated){
        res.status(401).send("unAutheriesed access")
    }else{
        console.log("checked user");
        next();
    }
}

export default {
    userAuth,
    adminAuth
}



# user schema method to in the models file


userSchema.methods.getJWT = async function () {
    const user = this;

    const token = await jwt.sign({_id:user?._id},"satendra@44456",{
        expiresIn : "1d",
    });

    return token;
}

userSchema.methods.validatePassword = async function (inputPassword) {
    const user = this;
    const passeordHash = user.password;
                                              //(user input the password put on this place
    const passwordValid = await bcrypt.compare(inputPassword,passeordHash);
                                                            // ,Store the data base password hash put 0n this place)
    return passwordValid;
}


# update API user 


profileRoutes.patch("/updateProfile/:userId",userAuth, async(req, res) => {

    const userId = req.params?.userId;
    const data = req.body;

    
    try {
        const ALLOWED_UPDATE = [
            "_id",
            "photoUrl",
            "about",
            "gender",
            "age",
            "skills",
            "emailId"
        ]
    
        const updateAllowed = Object.keys(data).every((k) => ALLOWED_UPDATE.includes(k));
    
        if(!updateAllowed){
            res.status(406).send("Not Allowed Upadte this fild")
        }

        if(data?.skills.length > 10){
            throw new Error("not allowed more 10 skills");
        }
        
        const user = await User.findByIdAndUpdate(userId,data,{returnDocument: "after"})
        // await user.save()
        res.send(`data are updated successfully ${user}`);
        
    } catch (error) {
        res.status(500).send(`Somthing want Wronge(in UpdateAPI) ${error}`)
    }
})